import pandas as pd
import os
from datetime import datetime

# Define the source files and output
MESSAGES_CSV = 'can bus messages - Messages.csv'
FEATURES_CSV = 'can bus messages - Features.csv'
OUTPUT_HEADER = 'canbus_msg.h'

def generate_header():
    # 1. Start building the content with a timestamp
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    header_content = [
        "/**",
        " * @file canbus_msg.h",
        f" * @brief Autogenerated CAN definitions - Generated on {timestamp}",
        " * @note DO NOT EDIT MANUALLY",
        " */",
        "#ifndef CANBUS_MSG_H_",
        "#define CANBUS_MSG_H_",
        "",
        "#include <stdint.h>",
        "",
    ]

    # Global alignment width
    ALIGN = 65

    # 2. Process Features CSV
    if os.path.exists(FEATURES_CSV):
        header_content.append("/* ========================================================================== */")
        header_content.append("/* --- 16-BIT FEATURE MASKS ---                                               */")
        header_content.append("/* ========================================================================== */")
        
        # Read Features CSV (Header is on Row 3, index 2)
        feat_df = pd.read_csv(FEATURES_CSV, header=2)
        feat_df.columns = [col.replace('\n', ' ').strip() for col in feat_df.columns]
        
        # Filter rows with a valid mask name
        feat_df = feat_df.dropna(subset=['mask name'])
        
        for _, row in feat_df.iterrows():
            name = str(row['mask name']).strip()
            # Clean up hex values (remove 0x if present or handle as strings)
            h_byte = str(row['high byte']).replace('0x', '').strip()
            l_byte = str(row['low byte']).replace('0x', '').strip()
            desc = str(row['node type']).strip() if pd.notnull(row['node type']) else ""
            
            try:
                # Combine bytes into a 16-bit hex string
                val_16 = f"0x{h_byte}{l_byte}"
                line = f"#define {name:<{ALIGN}} ((uint16_t){val_16})"
                if desc:
                    line += f" /** feature mask for {desc} */"
                header_content.append(line)
            except:
                continue
        header_content.append("")

    # 3. Process Messages CSV
    if os.path.exists(MESSAGES_CSV):
        header_content.append("/* ========================================================================== */")
        header_content.append("/* --- CAN MESSAGE IDS AND DLCS ---                                           */")
        header_content.append("/* ========================================================================== */")
        
        # Read Messages CSV (Header is on Row 6, index 5)
        msg_df = pd.read_csv(MESSAGES_CSV, header=5)
        msg_df.columns = [col.replace('\n', ' ').strip() for col in msg_df.columns]
        
        # Filter for rows with a valid C definition name
        msg_df = msg_df.dropna(subset=['c def'])
        msg_df = msg_df[msg_df['c def'].astype(str).str.strip() != '']
        
        for _, row in msg_df.iterrows():
            name = str(row['c def']).strip()
            msg_id = str(row['Message ID']).strip()
            dlc = row['DLC']
            comment = str(row['Comments']).strip() if pd.notnull(row['Comments']) else ""

            if msg_id and msg_id.lower() != 'nan':
                # ID line
                id_macro = f"CAN_ID_{name}"
                id_line = f"#define {id_macro:<{ALIGN}} ({msg_id})"
                if comment:
                    id_line += f" /** {comment} */"
                header_content.append(id_line)
                
                # DLC line
                try:
                    if pd.notnull(dlc):
                        dlc_val = int(float(dlc))
                        dlc_macro = f"CAN_DLC_{name}"
                        header_content.append(f"#define {dlc_macro:<{ALIGN}} ({dlc_val})")
                except:
                    pass
                header_content.append("") # Spacer between pairs

    header_content.append("#endif /* CANBUS_MSG_H_ */")

    # 4. Write the file (Force UTF-8 for safe reading in STM32Cube)
    with open(OUTPUT_HEADER, 'w', encoding='utf-8') as f:
        f.write("\n".join(header_content))
    
    print(f"[{datetime.now().strftime('%H:%M:%S')}] Success: '{OUTPUT_HEADER}' generated.")

if __name__ == "__main__":
    generate_header()